"""Tests for models file."""

import sys

import pytest

from open_alchemy import models_file

_DOCSTRING = '"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""'
_LONG_NAME = "extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa"
_EXPECTED_BASE = "typing.TypedDict"
if sys.version_info[1] < 8:
    _EXPECTED_BASE = "typing_extensions.TypedDict"
_ADDITIONAL_IMPORT = ""
if sys.version_info[1] < 8:
    _ADDITIONAL_IMPORT = """
import typing_extensions"""


@pytest.mark.parametrize(
    "schemas, expected_source",
    [
        (
            [({"properties": {"id": {"type": "integer"}}}, "Model")],
            f'''{_DOCSTRING}
# pylint: disable=no-member,useless-super-delegation

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models


class ModelDict({_EXPECTED_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]


class Model(models.Model):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: typing.Optional[int]

    def __init__(self, id: typing.Optional[int] = None) -> None:
        """Construct."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        super().__init__(**kwargs)

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None) -> "Model":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        return super().from_dict(**kwargs)

    def to_dict(self) -> ModelDict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()
''',
        ),
        (
            [
                ({"properties": {"id": {"type": "integer"}}}, "Model1"),
                ({"properties": {"id": {"type": "string"}}}, "Model2"),
            ],
            f'''{_DOCSTRING}
# pylint: disable=no-member,useless-super-delegation

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models


class Model1Dict({_EXPECTED_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]


class Model1(models.Model1):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: typing.Optional[int]

    def __init__(self, id: typing.Optional[int] = None) -> None:
        """Construct."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        super().__init__(**kwargs)

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None) -> "Model1":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        return super().from_dict(**kwargs)

    def to_dict(self) -> Model1Dict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()


class Model2Dict({_EXPECTED_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[str]


class Model2(models.Model2):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: typing.Optional[str]

    def __init__(self, id: typing.Optional[str] = None) -> None:
        """Construct."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        super().__init__(**kwargs)

    @classmethod
    def from_dict(cls, id: typing.Optional[str] = None) -> "Model2":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        return super().from_dict(**kwargs)

    def to_dict(self) -> Model2Dict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()
''',
        ),
        (
            [({"properties": {_LONG_NAME: {"type": "integer"}}}, "Model")],
            f'''{_DOCSTRING}
# pylint: disable=no-member,useless-super-delegation

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models


class ModelDict({_EXPECTED_BASE}, total=False):
    """TypedDict for properties that are not required."""

    extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa: typing.Optional[int]


class Model(models.Model):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa: typing.Optional[int]

    def __init__(
        self,
        extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa: typing.Optional[
            int
        ] = None,
    ) -> None:
        """Construct."""
        kwargs = {{}}
        if extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa is not None:
            kwargs[
                "extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa"
            ] = extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa

        super().__init__(**kwargs)

    @classmethod
    def from_dict(
        cls,
        extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa: typing.Optional[
            int
        ] = None,
    ) -> "Model":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {{}}
        if extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa is not None:
            kwargs[
                "extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa"
            ] = extremely_long_name_that_will_cause_wrapping_aaaaaaaaaaaaaaaaa

        return super().from_dict(**kwargs)

    def to_dict(self) -> ModelDict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()
''',
        ),
    ],
    ids=["single", "multiple", "black"],
)
@pytest.mark.only_this
@pytest.mark.models_file
def test_integration(schemas, expected_source):
    """
    GIVEN schema and name
    WHEN schema is added to the models file and the models file is generated
    THEN the models source code is returned.
    """
    models = models_file.ModelsFile()
    for schema, name in schemas:
        models.add_model(schema=schema, name=name)
    source = models.generate_models()

    assert source == expected_source


@pytest.mark.only_this
@pytest.mark.models_file
def test_schema_change():
    """
    GIVEN schema and name
    WHEN schema is added to the models file, changed and then the models file is
        generated
    THEN the change is reflected in the models file.
    """
    schema = {"properties": {}}
    name = "Model"
    models = models_file.ModelsFile()

    models.add_model(schema=schema, name=name)
    schema["properties"]["id"] = {"type": "integer"}
    source = models.generate_models()

    expected_source = f'''{_DOCSTRING}
# pylint: disable=no-member,useless-super-delegation

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models


class ModelDict({_EXPECTED_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]


class Model(models.Model):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: typing.Optional[int]

    def __init__(self, id: typing.Optional[int] = None) -> None:
        """Construct."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        super().__init__(**kwargs)

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None) -> "Model":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {{}}
        if id is not None:
            kwargs["id"] = id

        return super().from_dict(**kwargs)

    def to_dict(self) -> ModelDict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()
'''
    assert source == expected_source
